#!/usr/bin/env bash
# TACO - Tmux Agent Command Orchestrator
# Main executable that loads all modules

# Find the installation directory (portable symlink resolution)
# Resolves the real path of this script even through symlinks
__taco_source__="${BASH_SOURCE[0]}"
while [ -h "$__taco_source__" ]; do
  __taco_dir__="$(cd -P "$(dirname "$__taco_source__")" && pwd)"
  __taco_source__="$(readlink "$__taco_source__")"
  [[ "$__taco_source__" != /* ]] && __taco_source__="${__taco_dir__}/${__taco_source__}"
done
__taco_dir__="$(cd -P "$(dirname "$__taco_source__")" && pwd)"
TACO_HOME="${__taco_dir__}/../"

# Source all modules
source "$TACO_HOME/lib/taco-common.sh"
source "$TACO_HOME/lib/taco-pane-manager.sh"
source "$TACO_HOME/lib/taco-registry.sh"
source "$TACO_HOME/lib/taco-messaging.sh"
source "$TACO_HOME/lib/taco-testing.sh"
source "$TACO_HOME/lib/taco-monitoring.sh"
source "$TACO_HOME/lib/taco-docker.sh"
source "$TACO_HOME/lib/taco-agents.sh"
# Source new v2.0 modules
for module in taco-claude-subagents taco-hybrid-mode taco-mcp taco-hooks taco-settings taco-multi-agent taco-orchestration-v2; do
    if [ -f "$TACO_HOME/lib/${module}.sh" ]; then
        source "$TACO_HOME/lib/${module}.sh"
    fi
done

# Main execution starts here
main() {
    # Check for command line arguments first (before loading settings)
    # Load settings early so defaults (e.g., default agent/model) are available
    if declare -F load_taco_settings >/dev/null 2>&1; then
        load_taco_settings true
    fi
    PROMPT_FILE=""
    SKIP_INTERACTIVE=false
    AGENT_TYPE="${TACO_DEFAULT_AGENT:-claude}"  # Default from settings
    AGENT_FLAGS=""
    HYBRID_MODE=false
    MCP_ENABLED="${TACO_MCP_ENABLED:-true}"
    SUB_AGENTS_ENABLED="${TACO_SUB_AGENTS_ENABLED:-true}"
    CACHE_ENABLED=false
    THINKING_MODE=""
    MCP_SERVERS=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--file)
                PROMPT_FILE="$2"
                SKIP_INTERACTIVE=true
                shift 2
                ;;
            -p|--prompt)
                user_prompt="$2"
                SKIP_INTERACTIVE=true
                shift 2
                ;;
            -m|--model)
                # Select Claude model (e.g., sonnet, opus)
                export TACO_CLAUDE_MODEL="$2"
                shift 2
                ;;
            --codex)
                AGENT_TYPE="codex"
                shift
                ;;
            --gemini)
                AGENT_TYPE="gemini"
                shift
                ;;
            --openai)
                AGENT_TYPE="openai"
                shift
                ;;
            --anthropic-api)
                AGENT_TYPE="anthropic_api"
                shift
                ;;
            --llama)
                AGENT_TYPE="llama"
                shift
                ;;
            --mistral)
                AGENT_TYPE="mistral"
                shift
                ;;
            --custom)
                AGENT_TYPE="custom"
                CUSTOM_CONFIG="$2"
                shift 2
                ;;
            --hybrid)
                HYBRID_MODE=true
                shift
                ;;
            --cache)
                CACHE_ENABLED=true
                shift
                ;;
            --mcp-servers)
                MCP_SERVERS="$2"
                shift 2
                ;;
            --no-mcp)
                MCP_ENABLED=false
                shift
                ;;
            --no-subagents)
                SUB_AGENTS_ENABLED=false
                shift
                ;;
            --no-cache)
                CACHE_ENABLED=false
                shift
                ;;
            --settings)
                SETTINGS_FILE="$2"
                shift 2
                ;;
            --think)
                THINKING_MODE="$2"
                shift 2
                ;;
            --full-auto)
                if [ "$AGENT_TYPE" = "codex" ]; then
                    AGENT_FLAGS="--full-auto"
                else
                    echo -e "${YELLOW}Warning: --full-auto flag is only for codex agent${NC}"
                fi
                shift
                ;;
            --yolo)
                if [ "$AGENT_TYPE" = "gemini" ]; then
                    AGENT_FLAGS="--yolo"
                else
                    echo -e "${YELLOW}Warning: --yolo flag is only for gemini agent${NC}"
                fi
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                echo -e "${BLUE}üåÆ TACO v2.0.0${NC}"
                echo -e "${CYAN}Claude Sub-Agents | MCP | Multi-Model | Hybrid Mode${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Use -h or --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # Run safety check
    check_critical_processes
    
    # Agent selection (only if not skipping interactive mode)
    if [ "$SKIP_INTERACTIVE" = false ] && [ -z "$AGENT_TYPE" ]; then
        echo
        echo -e "${CYAN}ü§ñ AGENT SELECTION${NC}"
        echo -e "${YELLOW}Choose your orchestration mode:${NC}"
        echo "1. Claude with Sub-Agents (recommended)"
        echo "2. Hybrid Mode (multiple parallel agents)"
        echo "3. Classic TACO (tmux agents)"
        echo "4. OpenAI GPT-4"
        echo "5. Anthropic API"
        echo "6. Local Llama"
        echo "7. Codex (full-auto)"
        echo "8. Gemini (yolo mode)"
        echo "9. Custom Agent"
        read -r -p "Choose option (1-9, default 1): " agent_choice
        
        case $agent_choice in
            1)
                AGENT_TYPE="claude"
                SUB_AGENTS_ENABLED=true
                MCP_ENABLED=true
                ;;
            2)
                HYBRID_MODE=true
                ;;
            3)
                AGENT_TYPE="claude"
                SUB_AGENTS_ENABLED=false
                MCP_ENABLED=false
                ;;
            4)
                AGENT_TYPE="openai"
                ;;
            5)
                AGENT_TYPE="anthropic_api"
                ;;
            6)
                AGENT_TYPE="llama"
                ;;
            7)
                AGENT_TYPE="codex"
                AGENT_FLAGS="--full-auto"
                ;;
            8)
                AGENT_TYPE="gemini"
                AGENT_FLAGS="--yolo"
                ;;
            9)
                AGENT_TYPE="custom"
                read -r -p "Path to custom agent config: " CUSTOM_CONFIG
                ;;
            *)
                AGENT_TYPE="claude"
                SUB_AGENTS_ENABLED=true
                ;;
        esac
    fi
    
    # Old code removed - now using new agent selection above
    
    # Determine orchestrator vs worker agent types
    # Default: keep Mother as Claude for robust spec generation; workers use selected type
    MOTHER_AGENT_TYPE="${TACO_MOTHER_AGENT_TYPE:-claude}"
    WORKER_AGENT_TYPE="$AGENT_TYPE"
    if [ "$AGENT_TYPE" = "claude" ]; then
        MOTHER_AGENT_TYPE="claude"
        WORKER_AGENT_TYPE="claude"
    fi

    # Export agent configuration for use in other modules
    export TACO_AGENT_TYPE="$WORKER_AGENT_TYPE"
    export TACO_AGENT_FLAGS="$AGENT_FLAGS"
    export TACO_HYBRID_MODE="$HYBRID_MODE"
    export TACO_CACHE_ENABLED="$CACHE_ENABLED"
    export TACO_THINKING_MODE="$THINKING_MODE"
    export TACO_MCP_SERVERS="$MCP_SERVERS"
    export TACO_MCP_ENABLED="$MCP_ENABLED"
    export TACO_SUB_AGENTS_ENABLED="$SUB_AGENTS_ENABLED"
    
    # Get project description
    if [ "$SKIP_INTERACTIVE" = false ]; then
        echo -e "${BLUE}üåÆ TACO v2.0.0${NC}"
        echo -e "${CYAN}üéØ PROJECT SETUP${NC}"
        echo
        echo -e "${YELLOW}What would you like to build?${NC}"
        echo -e "${CYAN}üí° You can provide a detailed description. Press Enter on empty line to finish.${NC}"
        echo -e "${CYAN}üí° Or type a single line and press Enter.${NC}"
        echo -e "${CYAN}üí° Or type 'file:' followed by a path to load from file.${NC}"
        echo
        
        user_prompt=$(read_multiline_input)
    elif [ -n "$PROMPT_FILE" ]; then
        # Load from file specified via command line
        if [ -f "$PROMPT_FILE" ]; then
            echo -e "${CYAN}üìÑ Loading project description from: $PROMPT_FILE${NC}"
            user_prompt=$(cat "$PROMPT_FILE")
            echo -e "${GREEN}‚úÖ Loaded $(echo "$user_prompt" | wc -l) lines from file${NC}"
        else
            echo -e "${RED}‚ùå File not found: $PROMPT_FILE${NC}"
            exit 1
        fi
    elif [ -n "$user_prompt" ]; then
        # Prompt provided via command line
        echo -e "${CYAN}üìã Using provided project description${NC}"
    fi
    
    # Check if user wants to load from file (interactive mode only)
    if [ "$SKIP_INTERACTIVE" = false ] && [[ "$user_prompt" =~ ^file:(.+)$ ]]; then
        file_path="${BASH_REMATCH[1]}"
        file_path="${file_path# }"  # Remove leading space
        
        if [ -f "$file_path" ]; then
            echo -e "${CYAN}üìÑ Loading from file: $file_path${NC}"
            user_prompt=$(cat "$file_path")
            echo -e "${GREEN}‚úÖ Loaded $(echo "$user_prompt" | wc -l) lines from file${NC}"
        else
            echo -e "${RED}‚ùå File not found: $file_path${NC}"
            echo -e "${YELLOW}Let's try again...${NC}"
            echo
            user_prompt=$(read_multiline_input)
        fi
    fi
    
    if [ -z "$user_prompt" ]; then
        echo -e "${RED}‚ùå No project description provided. Exiting.${NC}"
        exit 1
    fi
    
    # Show confirmation of the input (interactive mode only)
    if [ "$SKIP_INTERACTIVE" = false ]; then
        echo
        echo -e "${CYAN}üìã Project Description:${NC}"
        line_count=$(echo "$user_prompt" | wc -l)
        char_count=$(echo "$user_prompt" | wc -c)
        
        if [ $line_count -gt 10 ] || [ $char_count -gt 500 ]; then
            echo -e "${YELLOW}   üìä Large input detected: $line_count lines, $char_count characters${NC}"
            echo -e "${YELLOW}   First 10 lines preview:${NC}"
            echo "$user_prompt" | head -10 | sed 's/^/   /'
            [ $line_count -gt 10 ] && echo -e "${YELLOW}   ... (and $((line_count - 10)) more lines)${NC}"
        else
            echo "$user_prompt" | sed 's/^/   /'
        fi
        
        echo
        echo -e "${YELLOW}Is this correct? (Y/n/v to view full text):${NC}"
        read -r -p "> " confirm_prompt
        
        case "$confirm_prompt" in
            [Vv]*)
                echo
                echo -e "${CYAN}üìã Full Project Description:${NC}"
                echo "$user_prompt" | sed 's/^/   /'
                echo
                echo -e "${YELLOW}Is this correct? (Y/n):${NC}"
                read -r -p "> " confirm_prompt
                ;;
        esac
        
        if [[ "$confirm_prompt" =~ ^[Nn]$ ]]; then
            echo -e "${YELLOW}Let's try again...${NC}"
            echo
            user_prompt=$(read_multiline_input)
            
            # Check for file input again
            if [[ "$user_prompt" =~ ^file:(.+)$ ]]; then
                file_path="${BASH_REMATCH[1]}"
                file_path="${file_path# }"
                
                if [ -f "$file_path" ]; then
                    echo -e "${CYAN}üìÑ Loading from file: $file_path${NC}"
                    user_prompt=$(cat "$file_path")
                    echo -e "${GREEN}‚úÖ Loaded $(echo "$user_prompt" | wc -l) lines from file${NC}"
                else
                    echo -e "${RED}‚ùå File not found: $file_path${NC}"
                    echo -e "${RED}‚ùå No project description provided. Exiting.${NC}"
                    exit 1
                fi
            fi
            
            if [ -z "$user_prompt" ]; then
                echo -e "${RED}‚ùå No project description provided. Exiting.${NC}"
                exit 1
            fi
        fi
    fi
    
    # Configuration with intelligent defaults
    echo
    echo -e "${CYAN}üîß DEVELOPMENT CONFIGURATION${NC}"
    echo -e "${GREEN}‚úÖ Using optimized defaults for robust development${NC}"
    echo
    
    # Set comprehensive testing as non-negotiable
    TESTING_STRATEGY="comprehensive"
    echo -e "${YELLOW}Testing Strategy: ${GREEN}Comprehensive (unit + integration + e2e + api tests)${NC}"
    
    # Detect Docker environment and set smart defaults
    if command -v docker >/dev/null 2>&1 && docker ps >/dev/null 2>&1; then
        DEPLOYMENT_ENV="docker"
        echo -e "${YELLOW}Deployment Environment: ${GREEN}Docker containers (auto-detected)${NC}"
    else
        DEPLOYMENT_ENV="local"
        echo -e "${YELLOW}Deployment Environment: ${GREEN}Local development (auto-detected)${NC}"
    fi
    
    # Always use automatic port assignment for simplicity
    CONNECTION_STRATEGY="automatic"
    echo -e "${YELLOW}Connection Management: ${GREEN}Automatic port assignment (recommended)${NC}"
    
    # Set comprehensive debugging and testing as mandatory
    ERROR_HANDLING="comprehensive"
    CURL_TESTING="true"
    BUILD_VALIDATION="true"
    LOG_MONITORING="true"
    
    echo -e "${YELLOW}Error Handling: ${GREEN}Comprehensive debugging (mandatory)${NC}"
    echo -e "${YELLOW}Endpoint Testing: ${GREEN}Enabled with curl (mandatory)${NC}"
    echo -e "${YELLOW}Build Validation: ${GREEN}Enabled (mandatory)${NC}"
    echo -e "${YELLOW}Log Monitoring: ${GREEN}Enabled (mandatory)${NC}"
    echo
    echo -e "${CYAN}üí° All settings optimized for best practices. Manual override available via environment variables.${NC}"
    
    # Ask if user wants to create a new folder
    echo
    echo -e "${YELLOW}Create project in a new folder? (Y/n)${NC}"
    read -r -p "> " create_folder
    
    if [[ ! "$create_folder" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Enter folder name (or press Enter for auto-generated):${NC}"
        read -r -p "> " project_folder
        
        if [ -z "$project_folder" ]; then
            project_folder=$(echo "$user_prompt" | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]' | cut -c1-20)
        fi
        
        PROJECT_DIR="$(pwd)/$project_folder-$(date +%Y%m%d-%H%M%S)"
        mkdir -p "$PROJECT_DIR"
        cd "$PROJECT_DIR"
        
        echo -e "${GREEN}‚úÖ Created project directory: $PROJECT_DIR${NC}"
    else
        # If not creating a new folder, use current directory
        PROJECT_DIR="$(pwd)"
    fi
    
    # Update orchestrator directory
    ORCHESTRATOR_DIR="$PROJECT_DIR/.orchestrator"
    mkdir -p "$ORCHESTRATOR_DIR"
    
    # Initialize enhanced components
    create_connection_registry
    create_message_relay
    create_test_coordinator
    create_connection_validator
    create_port_helper
    create_docker_generator
    create_enhanced_monitor
    
    # Initialize logging
    log "INFO" "ORCHESTRATOR" "Starting TACO session for: $user_prompt"
    
    # Ask about agent count
    echo
    echo -e "${YELLOW}How many agents should I create? (Enter for auto, or 2-10):${NC}"
    read -r -p "> " agent_count
    
    if [ -n "$agent_count" ] && ! [[ "$agent_count" =~ ^[2-9]$|^10$ ]]; then
        echo -e "${YELLOW}Invalid count. Using auto mode.${NC}"
        agent_count="auto"
    fi
    
    # Ask about display mode
    echo
    echo -e "${YELLOW}How should agents be displayed?${NC}"
    echo "1. Separate windows (traditional mode)"
    echo "2. Single window with panes (up to 4 agents)"
    read -r -p "Choose option (1-2, default 1): " display_mode
    
    DISPLAY_MODE="windows"
    MAX_PANES=4  # Reduced to prevent "no space for new pane" errors
    
    case $display_mode in
        2)
            DISPLAY_MODE="panes"
            echo -e "${GREEN}‚úì Using pane mode (max $MAX_PANES agents in panes)${NC}"
            ;;
        *)
            DISPLAY_MODE="windows"
            echo -e "${GREEN}‚úì Using traditional window mode${NC}"
            ;;
    esac
    
    # Check for existing session
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Found existing TACO session${NC}"
        echo "1. Kill it and start fresh"
        echo "2. Exit without changes"
        read -r -p "Choose option (1-2): " choice
        
        case $choice in
            1)
                echo -e "${YELLOW}Killing existing session...${NC}"
                tmux kill-session -t "$SESSION_NAME"
                ;;
            *)
                echo -e "${GREEN}Exiting without changes.${NC}"
                exit 0
                ;;
        esac
    fi
    
    # Create tmux session with Mother in window 0
    echo -e "${GREEN}üñ•Ô∏è  Creating TACO session...${NC}"
    tmux new-session -d -s "$SESSION_NAME" -n "mother" -c "$PROJECT_DIR"
    
    # Create monitor window (window 1)
    tmux new-window -t "$SESSION_NAME:1" -n "monitor" -c "$PROJECT_DIR"
    
    # Initialize communication files and shared directories
    touch "$ORCHESTRATOR_DIR/communication.log"
    mkdir -p "$ORCHESTRATOR_DIR/messages"
    mkdir -p "$ORCHESTRATOR_DIR/shared_specs"
    echo "{}" > "$ORCHESTRATOR_DIR/shared_specs/README.md"
    
    # Start enhanced monitor
    tmux send-keys -t "$SESSION_NAME:1.0" "cd '$PROJECT_DIR' && watch -n 2 '$ORCHESTRATOR_DIR/show_status.sh'" Enter
    
    # Start Mother agent
    log "INFO" "MOTHER" "Starting Mother orchestrator"
    echo -e "${MAGENTA}üëë Starting Mother Orchestrator...${NC}"
    
    # Determine agent count instruction
    if [ "$agent_count" != "auto" ]; then
        count_instruction="You should create exactly $agent_count main agents (including tester and devops)."
    else
        count_instruction="Decide how many agents are needed (2-10 main agents, must include tester and devops)."
    fi
    
    # Create mother prompt
    mother_prompt_file="$ORCHESTRATOR_DIR/mother_prompt.txt"
    create_mother_prompt "$user_prompt" "$agent_count" "$count_instruction" > "$mother_prompt_file"
    
    # Launch Mother Agent
    agent_cmd=$(get_agent_command)
    echo -e "${YELLOW}Starting $MOTHER_AGENT_TYPE for Mother...${NC}"
    tmux send-keys -t "$SESSION_NAME:0.0" "cd '$PROJECT_DIR' && clear" Enter
    tmux send-keys -t "$SESSION_NAME:0.0" "$(get_agent_command "$MOTHER_AGENT_TYPE")" Enter
    
    # Wait for agent to start
    echo -e "${YELLOW}Waiting for $AGENT_TYPE to initialize...${NC}"
    sleep 5
    
    # Send the mother prompt
    echo -e "${YELLOW}Sending project requirements to Mother...${NC}"
    tmux send-keys -t "$SESSION_NAME:0.0" C-u
    sleep 0.5
    
    # Send prompt line by line
    while IFS= read -r line; do
        printf '%s\n' "$line" | tmux load-buffer -
        tmux paste-buffer -t "$SESSION_NAME:0.0"
        tmux send-keys -t "$SESSION_NAME:0.0" Enter
    done < "$mother_prompt_file"
    
    sleep 0.5
    tmux send-keys -t "$SESSION_NAME:0.0" Enter
    
    # Wait for specification
    echo -e "${CYAN}Waiting for Mother to output specification...${NC}"
    echo -e "${YELLOW}Debug: Check $ORCHESTRATOR_DIR/mother_output_debug.txt for Mother's output${NC}"
    sleep 15
    
    # Function to check for complete specification
    check_for_complete_spec() {
        local capture=$(tmux capture-pane -t "$SESSION_NAME:0.0" -p -S -3000)
        local clean_capture=$(echo "$capture" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/‚îÇ//g; s/‚ï∞//g; s/‚îÄ//g; s/‚ïØ//g' | sed 's/[[:space:]]*$//')
        
        echo "$clean_capture" > "$ORCHESTRATOR_DIR/mother_output_debug.txt"
        
        # Simply check if we have both START and END markers
        if echo "$clean_capture" | grep -i "AGENT_SPEC_START" > /dev/null && \
           echo "$clean_capture" | grep -i "AGENT_SPEC_END" > /dev/null; then
            
            # Get the last AGENT_SPEC block (in case there are examples in the prompt)
            local spec_content=$(echo "$clean_capture" | awk '
                /AGENT_SPEC_START/ { delete lines; i=0; capturing=1 }
                capturing { lines[i++] = $0 }
                /AGENT_SPEC_END/ { capturing=0; for(j=0; j<i; j++) final_lines[j] = lines[j] }
                END { for(j=0; j in final_lines; j++) print final_lines[j] }
            ')
            
            # Check if we have actual agent definitions
            if echo "$spec_content" | grep -E "AGENT:[0-9]+:" > /dev/null; then
                return 0
            fi
        fi
        return 1
    }
    
    # Wait with exponential backoff
    wait_for_spec_with_backoff() {
        local wait_time=2
        local total_wait=0
        local max_wait=$ORCHESTRATOR_TIMEOUT
        
        while [ $total_wait -lt $max_wait ]; do
            if check_for_complete_spec; then
                echo -e "${GREEN}‚úì Found complete agent specification!${NC}"
                log "INFO" "MOTHER" "Specification generated successfully"
                return 0
            fi
            
            echo -ne "\r${CYAN}Waiting for specification... ${total_wait}s${NC}"
            sleep $wait_time
            total_wait=$((total_wait + wait_time))
            wait_time=$((wait_time < 16 ? wait_time * 2 : 16))
        done
        
        echo
        return 1
    }
    
    if ! wait_for_spec_with_backoff; then
        log "ERROR" "MOTHER" "Failed to generate specification"
        echo -e "${RED}‚ùå Mother failed to generate specification${NC}"
        echo -e "${YELLOW}Debug: Mother's output was captured in:${NC}"
        echo -e "${YELLOW}  $ORCHESTRATOR_DIR/mother_output_debug.txt${NC}"
        echo -e "${YELLOW}Debug: Mother's prompt was:${NC}"
        echo -e "${YELLOW}  $ORCHESTRATOR_DIR/mother_prompt.txt${NC}"
        exit 1
    fi
    
    # Capture and process specification
    echo -e "${CYAN}Capturing specification...${NC}"
    sleep 2
    spec_file="$ORCHESTRATOR_DIR/agent_spec.txt"
    tmux capture-pane -t "$SESSION_NAME:0.0" -p -S -3000 > "$spec_file"
    
    # Clean and extract specification (remove ANSI codes and box drawing characters)
    # Extract only Mother's actual specification output after PROJECT ANALYSIS
    cleaned_file="$ORCHESTRATOR_DIR/cleaned_spec.txt"
    
    # First clean the file, then extract content after PROJECT ANALYSIS or AGENT SPECIFICATION
    cleaned_content=$(sed 's/\x1b\[[0-9;]*m//g; s/‚îÇ//g; s/‚ï∞//g; s/‚îÄ//g; s/‚ïØ//g; s/^[[:space:]]*//; s/[[:space:]]*$//' "$spec_file")
    analysis_line=$(echo "$cleaned_content" | grep -n -E "(PROJECT ANALYSIS|AGENT SPECIFICATION)" | tail -1 | cut -d: -f1)
    
    if [ -n "$analysis_line" ]; then
        echo "$cleaned_content" | tail -n +$analysis_line > "$cleaned_file"
    else
        echo "$cleaned_content" > "$cleaned_file"
    fi
    
    # Parse specification with smart window reassignment
    echo -e "${CYAN}Parsing agent specification...${NC}"
    agent_specs_file="$ORCHESTRATOR_DIR/parsed_agents.txt"
    parse_agent_specification "$cleaned_file" "$agent_specs_file"
    
    # Read agent specs from file
    agent_specs=()
    while IFS= read -r spec; do
        [ -n "$spec" ] && agent_specs+=("$spec")
    done < "$agent_specs_file"
    
    if [ ${#agent_specs[@]} -eq 0 ]; then
        log "ERROR" "PARSER" "No agents found in specification"
        echo -e "${RED}‚ùå Failed to parse agent specification${NC}"
        exit 1
    fi
    
    # Validate specification quality
    if ! validate_agent_specification "${agent_specs[@]}"; then
        echo -e "${RED}‚ùå Agent specification validation failed${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}Creating ${#agent_specs[@]} agents...${NC}"
    echo -e "${CYAN}Parsed agents:${NC}"
    for spec in "${agent_specs[@]}"; do
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        echo -e "  ${YELLOW}Window $window_num: ${GREEN}$agent_name${NC} - $agent_role"
    done
    log "INFO" "ORCHESTRATOR" "Creating ${#agent_specs[@]} agents"
    
    # Show final agent list
    echo -e "${CYAN}Final agent assignments:${NC}"
    for spec in "${agent_specs[@]}"; do
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        echo "  Window $window_num: $agent_name - $agent_role"
    done
    echo
    
    # Save state
    save_state "$user_prompt" "${agent_specs[@]}"
    
    # Create agent containers with enhanced robustness
    create_agent_containers "${agent_specs[@]}"
    
    # Initialize all agent instances with validation
    agent_cmd=$(get_agent_command "$WORKER_AGENT_TYPE")
    echo -e "${CYAN}Initializing $WORKER_AGENT_TYPE instances...${NC}"
    for idx in "${!agent_specs[@]}"; do
        spec="${agent_specs[$idx]}"
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        
        pane_address=$(get_pane_address $window_num "$agent_name")
        
        echo -e "${CYAN}Starting $WORKER_AGENT_TYPE for $agent_name at $pane_address${NC}"
        log "INFO" "AGENT-$agent_name" "Starting $WORKER_AGENT_TYPE instance at $pane_address"
        
        # Validate pane exists and check if agent is already running
        if tmux list-panes -t "$pane_address" >/dev/null 2>&1; then
            # Check if agent is already running in this pane (check for any of the agent types)
            if tmux capture-pane -t "$pane_address" -p | grep -qE "claude|codex|gemini|openai|ollama|mistral"; then
                log "INFO" "AGENT-$agent_name" "$WORKER_AGENT_TYPE already running in $pane_address, skipping"
            else
                tmux send-keys -t "$pane_address" "$agent_cmd" Enter &
            fi
        else
            log "ERROR" "AGENT-$agent_name" "Cannot start $AGENT_TYPE - pane $pane_address not found"
            echo -e "${RED}‚ùå Cannot start $AGENT_TYPE for $agent_name - pane not found${NC}"
        fi
    done
    wait
    
    echo -e "${YELLOW}Waiting for all $AGENT_TYPE instances to initialize...${NC}"
    sleep 10
    
    # Extra delay to ensure Mother's output is complete
    echo -e "${YELLOW}Ensuring clean agent initialization...${NC}"
    sleep 5
    
    # Send prompts to all agents with enhanced testing focus
    echo -e "${CYAN}Sending prompts to agents...${NC}"
    agent_deps=()
    agent_notifies=()
    agent_waits=()
    
    # Re-read the specification to get dependencies
    current_agent_idx=-1
    while IFS= read -r line; do
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$line" ] && continue
        
        if [[ "$line" =~ ^AGENT:([0-9]+):([^:]+):(.+)$ ]]; then
            current_agent_idx=$((current_agent_idx + 1))
        elif [[ "$line" =~ ^DEPENDS_ON:(.+)$ ]] && [ $current_agent_idx -ge 0 ]; then
            agent_deps[$current_agent_idx]="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^NOTIFIES:(.+)$ ]] && [ $current_agent_idx -ge 0 ]; then
            agent_notifies[$current_agent_idx]="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^WAIT_FOR:(.+)$ ]] && [ $current_agent_idx -ge 0 ]; then
            agent_waits[$current_agent_idx]="${BASH_REMATCH[1]}"
        fi
    done < <(awk '/AGENT_SPEC_START/,/AGENT_SPEC_END/' "$cleaned_file")
    
    for idx in "${!agent_specs[@]}"; do
        spec="${agent_specs[$idx]}"
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        depends_on="${agent_deps[$idx]:-none}"
        notifies="${agent_notifies[$idx]:-none}"
        wait_for="${agent_waits[$idx]:-none}"
        
        echo -e "${CYAN}Configuring $agent_name...${NC}"
        log "INFO" "AGENT-$agent_name" "Sending initial prompt"
        
        # Store agent information for validation
        agent_roles[$window_num]="$agent_role"
        agent_addresses[$window_num]="$pane_address"
        
        # Create agent prompt with testing focus
        agent_prompt=$(create_agent_prompt "$window_num" "$agent_name" "$agent_role" "$depends_on" "$notifies" "$wait_for" "$user_prompt" "${agent_specs[@]}")
        
        pane_address=$(get_pane_address $window_num "$agent_name")
        
        echo -e "${CYAN}Sending prompt to $agent_name at $pane_address${NC}"
        log "INFO" "AGENT-$agent_name" "Sending prompt to $pane_address"
        
        # Validate pane exists before sending prompt
        if tmux list-panes -t "$pane_address" >/dev/null 2>&1; then
            # Wait a bit more for Claude to be ready
            sleep 2
            
            # Send the entire prompt at once
            printf '%s' "$agent_prompt" | tmux load-buffer -
            tmux paste-buffer -t "$pane_address"
            
            # Small delay before Enter
            sleep 0.5
            tmux send-keys -t "$pane_address" Enter
        else
            log "ERROR" "AGENT-$agent_name" "Cannot send prompt - pane $pane_address not found"
            echo -e "${RED}‚ùå Cannot send prompt to $agent_name - pane not found${NC}"
        fi
        
        echo "[SYSTEM]: Created $agent_name in window $window_num" >> "$ORCHESTRATOR_DIR/communication.log"
    done
    
    echo -e "${GREEN}‚úÖ All agents created successfully!${NC}"
    log "INFO" "ORCHESTRATOR" "All agents initialized successfully"
    
    # PHASE 2: Transition Mother to Coordination Mode
    sleep 3
    echo -e "${MAGENTA}üëë Transitioning Mother to COORDINATION MODE...${NC}"
    
    # Build coordination prompt with all necessary info
    local testing_requirements="comprehensive testing including unit tests, integration tests, end-to-end tests, and API endpoint tests"
    local deployment_guidance="Focus on local development with production-ready structure"
    local connection_strategy="Automatically assign ports starting from 3000"
    
    # Create the coordination prompt
    coord_prompt_file="$ORCHESTRATOR_DIR/coordination_prompt.txt"
    create_coordination_prompt "$testing_requirements" "$deployment_guidance" "$connection_strategy" "$PROJECT_DIR" > "$coord_prompt_file"
    
    # Add agent list to coordination prompt
    echo "" >> "$coord_prompt_file"
    echo "=== ACTIVE AGENTS ===" >> "$coord_prompt_file"
    for idx in "${!agent_specs[@]}"; do
        spec="${agent_specs[$idx]}"
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        echo "Window $window_num: $agent_name - $agent_role" >> "$coord_prompt_file"
    done
    echo "" >> "$coord_prompt_file"
    echo "START COORDINATING NOW! Assign workspaces and tasks to each agent." >> "$coord_prompt_file"
    
    # Send coordination prompt to Mother
    echo -e "${YELLOW}Sending coordination instructions to Mother...${NC}"
    tmux send-keys -t "$SESSION_NAME:0.0" C-u
    sleep 0.5
    
    # Send the coordination prompt
    while IFS= read -r line; do
        printf '%s\n' "$line" | tmux load-buffer -
        tmux paste-buffer -t "$SESSION_NAME:0.0"
        tmux send-keys -t "$SESSION_NAME:0.0" Enter
    done < "$coord_prompt_file"
    
    sleep 0.5
    tmux send-keys -t "$SESSION_NAME:0.0" Enter
    
    echo -e "${GREEN}‚úÖ Mother is now in COORDINATION MODE!${NC}"
    echo -e "${CYAN}Mother will now coordinate all agents to build the project.${NC}"

    # Display final status
    clear
    echo -e "${GREEN}‚úÖ TACO FULLY INITIALIZED!${NC}"
    echo
    echo -e "${MAGENTA}Project: $user_prompt${NC}"
    echo -e "${CYAN}Project Directory: $PROJECT_DIR${NC}"
    echo -e "${CYAN}Session: $SESSION_NAME${NC}"
    echo
    echo -e "${YELLOW}Display Mode: ${DISPLAY_MODE}${NC}"
    echo
    echo -e "${YELLOW}Created Agents:${NC}"
    for idx in "${!agent_specs[@]}"; do
        spec="${agent_specs[$idx]}"
        IFS=':' read -r window_num agent_name agent_role <<< "$spec"
        if [ "$DISPLAY_MODE" = "panes" ] && [ $window_num -gt 1 ]; then
            pane_idx=$((window_num - 2))
            echo "  Window 2, Pane $pane_idx: $agent_name"
        else
            echo "  Window $window_num: $agent_name"
        fi
    done
    echo
    echo -e "${YELLOW}Configuration:${NC}"
    echo "  ‚Ä¢ CLI Agent: $AGENT_TYPE $([ -n "$AGENT_FLAGS" ] && echo "($AGENT_FLAGS)")"
    echo "  ‚Ä¢ Testing Strategy: $TESTING_STRATEGY"
    echo "  ‚Ä¢ Deployment Environment: $DEPLOYMENT_ENV"
    echo "  ‚Ä¢ Connection Management: $CONNECTION_STRATEGY"
    echo "  ‚Ä¢ Error Handling: $ERROR_HANDLING"
    echo "  ‚Ä¢ Curl Testing: $CURL_TESTING"
    echo "  ‚Ä¢ Build Validation: $BUILD_VALIDATION"
    echo "  ‚Ä¢ Log Monitoring: $LOG_MONITORING"
    echo
    echo -e "${YELLOW}Enhanced Features:${NC}"
    echo "  ‚Ä¢ Configurable test coordination and failure routing"
    echo "  ‚Ä¢ Dynamic connection registry and validation"
    echo "  ‚Ä¢ Intelligent build error detection and recovery"
    echo "  ‚Ä¢ Automated endpoint testing (configurable)"
    echo "  ‚Ä¢ Smart Docker/localhost conflict detection"
    echo "  ‚Ä¢ Reliable agent-to-mother message relay"
    echo
    echo -e "${YELLOW}Key Files:${NC}"
    echo "  ‚Ä¢ Connection Registry: $ORCHESTRATOR_DIR/connections.json"
    echo "  ‚Ä¢ Message Relay: $ORCHESTRATOR_DIR/message_relay.sh"
    echo "  ‚Ä¢ Port Helper: $ORCHESTRATOR_DIR/port_helper.sh"
    echo "  ‚Ä¢ Test Results: $ORCHESTRATOR_DIR/test_results.log"
    echo "  ‚Ä¢ Validation Log: $ORCHESTRATOR_DIR/validation.log"
    echo
    echo -e "${YELLOW}Navigation:${NC}"
    if [ "$DISPLAY_MODE" = "panes" ]; then
        echo "  ‚Ä¢ Ctrl+b + 2: Jump to agents window"
        echo "  ‚Ä¢ Ctrl+b + arrow keys: Navigate between panes"
    else
        echo "  ‚Ä¢ Ctrl+b + [0-9]: Jump to specific window"
    fi
    echo "  ‚Ä¢ Ctrl+b + 2: Test monitor window"
    echo "  ‚Ä¢ Ctrl+b + d: Detach (everything keeps running)"
    echo
    echo -e "${GREEN}üåÆ Attaching to TACO session in 3 seconds...${NC}"
    echo -e "${CYAN}You'll start in the Mother window (0)${NC}"
    
    sleep 3
    
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        tmux attach -t "$SESSION_NAME:0"
    else
        echo -e "${RED}‚ùå Failed to create TACO session${NC}"
        echo -e "${YELLOW}Check logs at: $ORCHESTRATOR_DIR/orchestrator.log${NC}"
        exit 1
    fi
}

# Run main function
main "$@"
